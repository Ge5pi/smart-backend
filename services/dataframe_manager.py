# services/dataframe_manager.py
import pandas as pd
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
import logging
from sqlalchemy import inspect, text
import numpy as np
import sys
import os

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞ utils
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.json_serializer import convert_to_serializable, clean_dataframe_for_json

logger = logging.getLogger(__name__)


@dataclass
class TableRelation:
    """–û–ø–∏—Å–∞–Ω–∏–µ —Å–≤—è–∑–∏ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∞–º–∏"""
    from_table: str
    to_table: str
    from_column: str
    to_column: str
    relation_type: str  # one_to_many, many_to_many, one_to_one


class DataFrameManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–≤—è–∑–∞–Ω–Ω—ã–º–∏ DataFrame"""

    def __init__(self, engine):
        self.engine = engine
        self.tables: Dict[str, pd.DataFrame] = {}
        self.relations: List[TableRelation] = []
        self.table_schemas: Dict[str, Dict] = {}
        self.total_memory_usage = 0.0

    def load_all_tables(self, max_rows_per_table: int = 100000) -> Dict[str, pd.DataFrame]:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –ø–∞–º—è—Ç—å –∫–∞–∫ DataFrame"""
        inspector = inspect(self.engine)
        tables_loaded = 0

        logger.info("–ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü –≤ DataFrame...")

        for table_name in inspector.get_table_names():
            if table_name in ['alembic_version', 'django_migrations', 'schema_migrations']:
                continue

            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ç–∞–±–ª–∏—Ü—ã
                with self.engine.connect() as conn:
                    count_result = conn.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
                    row_count = count_result.scalar()

                if row_count == 0:
                    logger.info(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—É—é —Ç–∞–±–ª–∏—Ü—É {table_name}")
                    continue

                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ç–∞–±–ª–∏—Ü
                if row_count > max_rows_per_table:
                    logger.warning(
                        f"–¢–∞–±–ª–∏—Ü–∞ {table_name} —Å–æ–¥–µ—Ä–∂–∏—Ç {row_count} —Å—Ç—Ä–æ–∫, –∑–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ {max_rows_per_table}")
                    query = f"SELECT * FROM {table_name} LIMIT {max_rows_per_table}"
                else:
                    query = f"SELECT * FROM {table_name}"

                # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
                df = pd.read_sql(query, self.engine)

                if not df.empty:
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
                    df = self._clean_dataframe(df)

                    self.tables[table_name] = df

                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ö–µ–º—É —Ç–∞–±–ª–∏—Ü—ã
                    columns = inspector.get_columns(table_name)
                    primary_keys = []
                    try:
                        pk_constraint = inspector.get_pk_constraint(table_name)
                        primary_keys = pk_constraint.get('constrained_columns', []) if pk_constraint else []
                    except:
                        primary_keys = []

                    memory_mb = df.memory_usage(deep=True).sum() / 1024 / 1024

                    self.table_schemas[table_name] = {
                        'columns': {col['name']: str(col['type']) for col in columns},
                        'row_count': len(df),
                        'total_row_count': int(row_count),
                        'primary_keys': primary_keys,
                        'memory_usage_mb': round(memory_mb, 3),
                        'is_truncated': row_count > max_rows_per_table
                    }

                    tables_loaded += 1
                    self.total_memory_usage += memory_mb

                    logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞ {table_name}: {len(df)}/{row_count} —Å—Ç—Ä–æ–∫, {memory_mb:.2f} MB")

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {table_name}: {e}")

        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–≤—è–∑–∏ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∞–º–∏
        self._discover_relations(inspector)

        logger.info(f"üéâ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {tables_loaded} —Ç–∞–±–ª–∏—Ü, {len(self.relations)} —Å–≤—è–∑–µ–π, "
                    f"–æ–±—â–∏–π –æ–±—ä–µ–º: {self.total_memory_usage:.2f} MB")

        return self.tables

    def _clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """–û—á–∏—â–∞–µ—Ç DataFrame –æ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π"""
        try:
            df_clean = df.copy()

            # –ó–∞–º–µ–Ω—è–µ–º inf –Ω–∞ NaN
            df_clean = df_clean.replace([np.inf, -np.inf], np.nan)

            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
            for col in df_clean.columns:
                if df_clean[col].dtype == 'object':
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º None –≤ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –æ–±—ä–µ–∫—Ç–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫
                    df_clean[col] = df_clean[col].astype(str).replace('None', '').replace('nan', '')
                elif pd.api.types.is_numeric_dtype(df_clean[col]):
                    # –î–ª—è —á–∏—Å–ª–æ–≤—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ –∑–∞–º–µ–Ω—è–µ–º NaN –Ω–∞ 0 –µ—Å–ª–∏ –º–Ω–æ–≥–æ –ø—Ä–æ–ø—É—Å–∫–æ–≤
                    null_pct = df_clean[col].isnull().sum() / len(df_clean)
                    if null_pct > 0.5:  # –ï—Å–ª–∏ –±–æ–ª—å—à–µ 50% –ø—Ä–æ–ø—É—Å–∫–æ–≤
                        df_clean[col] = df_clean[col].fillna(0)
                elif df_clean[col].dtype.kind in ['M', 'm']:  # datetime/timedelta
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º datetime –≤ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                    try:
                        df_clean[col] = pd.to_datetime(df_clean[col], errors='coerce')
                        df_clean[col + '_str'] = df_clean[col].dt.strftime('%Y-%m-%d %H:%M:%S')
                    except:
                        pass

            return df_clean

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ DataFrame: {e}")
            return df

    def _discover_relations(self, inspector):
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç —Å–≤—è–∑–∏ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∞–º–∏"""
        relations_found = 0

        for table_name in self.tables.keys():
            try:
                foreign_keys = inspector.get_foreign_keys(table_name)
                for fk in foreign_keys:
                    referred_table = fk.get('referred_table')
                    if referred_table and referred_table in self.tables:
                        constrained_columns = fk.get('constrained_columns', [])
                        referred_columns = fk.get('referred_columns', [])

                        if constrained_columns and referred_columns:
                            relation = TableRelation(
                                from_table=table_name,
                                to_table=referred_table,
                                from_column=constrained_columns[0],
                                to_column=referred_columns[0],
                                relation_type='many_to_one'
                            )
                            self.relations.append(relation)
                            relations_found += 1

            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å FK –¥–ª—è {table_name}: {e}")

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ —Å–≤—è–∑–µ–π –ø–æ –∏–º–µ–Ω–∞–º –∫–æ–ª–æ–Ω–æ–∫
        self._discover_implicit_relations()

        logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ {len(self.relations)} —Å–≤—è–∑–µ–π –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∞–º–∏")

    def _discover_implicit_relations(self):
        """–ü–æ–∏—Å–∫ –Ω–µ—è–≤–Ω—ã—Ö —Å–≤—è–∑–µ–π –ø–æ –∏–º–µ–Ω–∞–º –∫–æ–ª–æ–Ω–æ–∫"""
        table_names = list(self.tables.keys())

        for i, table1 in enumerate(table_names):
            for table2 in table_names[i + 1:]:
                df1 = self.tables[table1]
                df2 = self.tables[table2]

                # –ò—â–µ–º –æ–±—â–∏–µ –∫–æ–ª–æ–Ω–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–≤—è–∑—è–º–∏
                common_columns = set(df1.columns).intersection(set(df2.columns))

                for col in common_columns:
                    if col.lower().endswith('_id') or col.lower() == 'id':
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π
                        try:
                            values1 = set(df1[col].dropna().astype(str))
                            values2 = set(df2[col].dropna().astype(str))

                            if len(values1.intersection(values2)) > 0:
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–∞–∫–æ–π —Å–≤—è–∑–∏ –µ—â–µ –Ω–µ—Ç
                                existing = any(
                                    (r.from_table == table1 and r.to_table == table2 and r.from_column == col) or
                                    (r.from_table == table2 and r.to_table == table1 and r.to_column == col)
                                    for r in self.relations
                                )

                                if not existing:
                                    relation = TableRelation(
                                        from_table=table1,
                                        to_table=table2,
                                        from_column=col,
                                        to_column=col,
                                        relation_type='implicit'
                                    )
                                    self.relations.append(relation)
                        except:
                            continue

    def join_tables(self, left_table: str, right_table: str,
                    join_type: str = 'inner', on: Optional[Dict[str, str]] = None) -> pd.DataFrame:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç JOIN –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∞–º–∏"""

        if left_table not in self.tables or right_table not in self.tables:
            raise ValueError(f"–¢–∞–±–ª–∏—Ü—ã {left_table} –∏–ª–∏ {right_table} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")

        left_df = self.tables[left_table].copy()
        right_df = self.tables[right_table].copy()

        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–≤—è–∑—å –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞
        if on is None:
            relation = self._find_relation(left_table, right_table)
            if relation:
                on = {relation.from_column: relation.to_column}
            else:
                # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –æ–±—â–∏–µ –∫–æ–ª–æ–Ω–∫–∏
                common_cols = set(left_df.columns).intersection(set(right_df.columns))
                if common_cols:
                    # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç ID –∫–æ–ª–æ–Ω–∫–∞–º
                    id_cols = [col for col in common_cols if 'id' in col.lower()]
                    common_col = id_cols[0] if id_cols else list(common_cols)[0]
                    on = {common_col: common_col}
                else:
                    raise ValueError(f"–°–≤—è–∑—å –º–µ–∂–¥—É {left_table} –∏ {right_table} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

        try:
            # –í—ã–ø–æ–ª–Ω—è–µ–º JOIN
            result = pd.merge(
                left_df, right_df,
                left_on=list(on.keys()),
                right_on=list(on.values()),
                how=join_type,
                suffixes=('_left', '_right')
            )

            logger.info(f"JOIN –≤—ã–ø–æ–ª–Ω–µ–Ω: {left_table} {join_type} {right_table} –Ω–∞ {on}, "
                        f"—Ä–µ–∑—É–ª—å—Ç–∞—Ç: {len(result)} —Å—Ç—Ä–æ–∫")

            return result

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ JOIN: {e}")
            raise

    def _find_relation(self, table1: str, table2: str) -> Optional[TableRelation]:
        """–ù–∞—Ö–æ–¥–∏—Ç —Å–≤—è–∑—å –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–∞–±–ª–∏—Ü–∞–º–∏"""
        # –ü—Ä—è–º–∞—è —Å–≤—è–∑—å
        for relation in self.relations:
            if relation.from_table == table1 and relation.to_table == table2:
                return relation

        # –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
        for relation in self.relations:
            if relation.from_table == table2 and relation.to_table == table1:
                return TableRelation(
                    from_table=table1,
                    to_table=table2,
                    from_column=relation.to_column,
                    to_column=relation.from_column,
                    relation_type=relation.relation_type
                )

        return None

    def complex_query(self, operations: List[Dict[str, Any]]) -> pd.DataFrame:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏"""
        result_df = None

        for i, op in enumerate(operations):
            op_type = op.get('type')
            logger.info(f"–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ {i + 1}: {op_type}")

            try:
                if op_type == 'select':
                    table_name = op['table']
                    columns = op.get('columns', None)

                    if table_name not in self.tables:
                        raise ValueError(f"–¢–∞–±–ª–∏—Ü–∞ {table_name} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

                    result_df = self.tables[table_name].copy()

                    if columns:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫
                        missing_cols = [col for col in columns if col not in result_df.columns]
                        if missing_cols:
                            logger.warning(f"–ö–æ–ª–æ–Ω–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã: {missing_cols}")
                            columns = [col for col in columns if col in result_df.columns]

                        if columns:
                            result_df = result_df[columns]

                elif op_type == 'join':
                    if result_df is None:
                        raise ValueError("JOIN —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ SELECT")

                    right_table = op['table']
                    join_type = op.get('how', 'inner')
                    on = op.get('on')

                    if right_table not in self.tables:
                        raise ValueError(f"–¢–∞–±–ª–∏—Ü–∞ {right_table} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

                    right_df = self.tables[right_table]

                    if on:
                        result_df = pd.merge(
                            result_df, right_df,
                            left_on=on['left'],
                            right_on=on['right'],
                            how=join_type,
                            suffixes=('', '_right')
                        )
                    else:
                        # –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–≤—è–∑–∏
                        common_cols = set(result_df.columns).intersection(set(right_df.columns))
                        if common_cols:
                            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç ID –∫–æ–ª–æ–Ω–∫–∞–º
                            id_cols = [col for col in common_cols if 'id' in col.lower()]
                            common_col = id_cols[0] if id_cols else list(common_cols)[0]
                            result_df = pd.merge(
                                result_df, right_df,
                                on=common_col,
                                how=join_type,
                                suffixes=('', '_right')
                            )
                        else:
                            raise ValueError(f"–ù–µ –Ω–∞–π–¥–µ–Ω—ã –æ–±—â–∏–µ –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è JOIN —Å {right_table}")

                elif op_type == 'filter':
                    if result_df is None:
                        raise ValueError("FILTER —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ SELECT")

                    condition = op['condition']
                    try:
                        result_df = result_df.query(condition)
                    except Exception as filter_error:
                        logger.error(f"–û—à–∏–±–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ '{condition}': {filter_error}")
                        # –ü—ã—Ç–∞–µ–º—Å—è –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–æ—Å—Ç—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é
                        if 'column' in op and 'value' in op:
                            col = op['column']
                            val = op['value']
                            if col in result_df.columns:
                                result_df = result_df[result_df[col] == val]

                elif op_type == 'groupby':
                    if result_df is None:
                        raise ValueError("GROUPBY —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ SELECT")

                    by = op['by']
                    agg_dict = op.get('agg', {})

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏
                    if isinstance(by, str):
                        by = [by]

                    existing_by = [col for col in by if col in result_df.columns]
                    if not existing_by:
                        logger.warning(f"–ö–æ–ª–æ–Ω–∫–∏ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã: {by}")
                        continue

                    # –í—ã–ø–æ–ª–Ω—è–µ–º –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É
                    if agg_dict:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ –¥–ª—è –∞–≥—Ä–µ–≥–∞—Ü–∏–∏
                        valid_agg = {k: v for k, v in agg_dict.items() if k in result_df.columns}
                        if valid_agg:
                            result_df = result_df.groupby(existing_by).agg(valid_agg).reset_index()
                    else:
                        # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Å–æ —Å—á–µ—Ç—á–∏–∫–æ–º
                        result_df = result_df.groupby(existing_by).size().reset_index(name='count')

                elif op_type == 'sort':
                    if result_df is None:
                        raise ValueError("SORT —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ SELECT")

                    by = op['by']
                    ascending = op.get('ascending', True)

                    if isinstance(by, str):
                        by = [by]

                    existing_by = [col for col in by if col in result_df.columns]
                    if existing_by:
                        result_df = result_df.sort_values(existing_by, ascending=ascending)

                elif op_type == 'limit':
                    if result_df is None:
                        raise ValueError("LIMIT —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ SELECT")

                    n = op['n']
                    result_df = result_df.head(n)

            except Exception as op_error:
                logger.error(f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏ {op_type}: {op_error}")
                if result_df is None:
                    result_df = pd.DataFrame()
                continue

        if result_df is None:
            result_df = pd.DataFrame()

        logger.info(f"–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∑–∞–≤–µ—Ä—à–µ–Ω, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {len(result_df)} —Å—Ç—Ä–æ–∫")
        return result_df

    def get_table_summary(self) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–≤–æ–¥–∫—É –ø–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–º —Ç–∞–±–ª–∏—Ü–∞–º"""
        return {
            'total_tables': len(self.tables),
            'total_relations': len(self.relations),
            'total_memory_mb': round(self.total_memory_usage, 2),
            'tables': {
                name: {
                    'rows': len(df),
                    'columns': len(df.columns),
                    'memory_mb': round(df.memory_usage(deep=True).sum() / 1024 / 1024, 3),
                    'schema_info': self.table_schemas.get(name, {})
                }
                for name, df in self.tables.items()
            },
            'relations': [
                {
                    'from_table': rel.from_table,
                    'to_table': rel.to_table,
                    'from_column': rel.from_column,
                    'to_column': rel.to_column,
                    'type': rel.relation_type
                }
                for rel in self.relations
            ]
        }

    def get_memory_usage(self) -> Dict[str, float]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–∞–º—è—Ç–∏"""
        memory_info = {}

        for table_name, df in self.tables.items():
            memory_usage = df.memory_usage(deep=True)
            memory_info[table_name] = {
                'total_mb': round(memory_usage.sum() / 1024 / 1024, 3),
                'per_column_mb': {
                    col: round(usage / 1024 / 1024, 3)
                    for col, usage in memory_usage.items()
                }
            }

        return memory_info

    def optimize_memory(self):
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏"""
        for table_name, df in self.tables.items():
            try:
                original_size = df.memory_usage(deep=True).sum()

                # –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º —á–∏—Å–ª–æ–≤—ã–µ —Ç–∏–ø—ã
                for col in df.select_dtypes(include=[np.number]).columns:
                    col_min = df[col].min()
                    col_max = df[col].max()

                    if pd.api.types.is_integer_dtype(df[col]):
                        if col_min >= 0:  # unsigned
                            if col_max < 255:
                                df[col] = df[col].astype(np.uint8)
                            elif col_max < 65535:
                                df[col] = df[col].astype(np.uint16)
                            elif col_max < 4294967295:
                                df[col] = df[col].astype(np.uint32)
                        else:  # signed
                            if col_min >= -128 and col_max <= 127:
                                df[col] = df[col].astype(np.int8)
                            elif col_min >= -32768 and col_max <= 32767:
                                df[col] = df[col].astype(np.int16)
                            elif col_min >= -2147483648 and col_max <= 2147483647:
                                df[col] = df[col].astype(np.int32)

                    elif pd.api.types.is_float_dtype(df[col]):
                        if abs(col_max) < 3.4e38 and abs(col_min) < 3.4e38:
                            df[col] = df[col].astype(np.float32)

                self.tables[table_name] = df
                new_size = df.memory_usage(deep=True).sum()

                if new_size < original_size:
                    saved_mb = (original_size - new_size) / 1024 / 1024
                    logger.info(f"–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞ {table_name}: —Å—ç–∫–æ–Ω–æ–º–ª–µ–Ω–æ {saved_mb:.2f} MB")

            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É {table_name}: {e}")
